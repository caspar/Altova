<?xml version="1.0" encoding="UTF-8"?>
<!--Designed and generated by Altova StyleVision Enterprise Edition 2015 - see http://www.altova.com/stylevision for more information.-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:acf="http://xbrl.org/2010/filter/aspect-cover" xmlns:altova="http://www.altova.com" xmlns:altovaext="http://www.altova.com/xslt-extensions" xmlns:cf="http://xbrl.org/2008/filter/concept" xmlns:clitype="clitype" xmlns:dei="http://xbrl.sec.gov/dei/2013-01-31" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:formula="http://xbrl.org/2008/formula" xmlns:gen="http://xbrl.org/2008/generic" xmlns:iso4217="http://www.xbrl.org/2003/iso4217" xmlns:ix="http://www.xbrl.org/2008/inlineXBRL" xmlns:java="java" xmlns:label="http://xbrl.org/2008/label" xmlns:link="http://www.xbrl.org/2003/linkbase" xmlns:map="http://www.w3.org/2005/xpath-functions/map" xmlns:math="http://www.w3.org/2005/xpath-functions/math" xmlns:msg="http://xbrl.org/2010/message" xmlns:n1="http://fasb.org/us-gaap/attributes" xmlns:n2="http://xbrl.us/us-types/2009-01-31" xmlns:n3="http://www.xbrl.org/2004/ref" xmlns:nanonull="http://www.altova.com/nanonull" xmlns:negated="http://xbrl.us/us-gaap/negated/2008-03-31" xmlns:nonnum="http://www.xbrl.org/dtr/type/non-numeric" xmlns:num="http://www.xbrl.org/dtr/type/numeric" xmlns:pf="http://xbrl.org/2008/filter/period" xmlns:ref="http://www.xbrl.org/2006/ref" xmlns:sps="http://www.altova.com/StyleVision/user-xpath-functions" xmlns:table="http://xbrl.org/2014/table" xmlns:us-gaap="http://fasb.org/us-gaap/2013-01-31" xmlns:us-gaap-att="http://xbrl.us/us-gaap/attributes" xmlns:us-roles="http://fasb.org/us-roles/2013-01-31" xmlns:us-types="http://fasb.org/us-types/2013-01-31" xmlns:utr="http://www.xbrl.org/2009/utr" xmlns:va="http://xbrl.org/2008/assertion/value" xmlns:valm="http://xbrl.org/2010/message/validation" xmlns:variable="http://xbrl.org/2008/variable" xmlns:xbrldi="http://xbrl.org/2006/xbrldi" xmlns:xbrldt="http://xbrl.org/2005/xbrldt" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns:xfi="http://www.xbrl.org/2008/function/instance" xmlns:xl="http://www.xbrl.org/2003/XLink" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" exclude-result-prefixes="#all">
	<xsl:output version="4.0" method="html" indent="no" encoding="UTF-8" use-character-maps="spaces" doctype-public="-//W3C//DTD HTML 4.01 Transitional//EN" doctype-system="http://www.w3.org/TR/html4/loose.dtd"/>
	<xsl:character-map name="spaces">
		<xsl:output-character character="&#160;" string="&amp;nbsp;"/>
	</xsl:character-map>
	<xsl:param name="altova:bGeneratingFromPxf" select="false()"/>
	<xsl:param name="SV_OutputFormat" select="'HTML'"/>
	<xsl:param name="SV_BaseOutputFileName" as="xs:string?">
		<xsl:sequence select="for $i in altovaext:get-base-output-uri(), $j in tokenize( $i, &apos;[/\\]&apos; )[last()] return replace( $j, &apos;\.[^\.\s#%;]*$&apos;, &apos;&apos; )" use-when="function-available(&apos;altovaext:get-base-output-uri&apos;)"/>
	</xsl:param>
	<xsl:param name="SV_GeneratedFileNamePrefix" select="if ( $SV_BaseOutputFileName ) then $SV_BaseOutputFileName else &apos;Charts&apos;" as="xs:string?"/>
	<xsl:variable name="XBRL" select="/"/>
	<xsl:variable name="altova:nPxPerIn" select="96"/>
	<xsl:decimal-format name="format1" grouping-separator="Â " decimal-separator=","/>
	<xsl:import-schema schema-location="nanonull.xsd" use-when="system-property('xsl:is-schema-aware')='yes'" namespace="http://www.altova.com/nanonull"/>
	<xsl:function name="altova:distinct-nodes">
		<xsl:param name="Param1"/>
		<xsl:sequence select="altovaext:distinct-nodes($Param1)" use-when="function-available('altovaext:distinct-nodes', 1)"/>
		<xsl:sequence select="$Param1[fn:empty(for $node in fn:subsequence($Param1, 1, position() - 1) return if (fn:deep-equal($node, .)) then $node else ())]" use-when="not(function-available('altovaext:distinct-nodes', 1))"/>
	</xsl:function>
	<xsl:function name="altova:xbrl-footnotes">
		<xsl:sequence select="altovaext:xbrl-footnotes" use-when="function-available('altovaext:xbrl-footnotes', 0)"/>
		<xsl:sequence select="()" use-when="not(function-available('altovaext:xbrl-footnotes', 0))"/>
	</xsl:function>
	<xsl:function name="altova:xbrl-labels">
		<xsl:sequence select="altovaext:xbrl-labels" use-when="function-available('altovaext:xbrl-labels', 0)"/>
		<xsl:sequence select="()" use-when="not(function-available('altovaext:xbrl-labels', 0))"/>
	</xsl:function>
	<xsl:variable name="altova:CssImages" select="()"/>
	<xsl:variable name="altova:XBRL-xbrl-contexts" select="$XBRL/xbrli:xbrl/xbrli:context"/>
	<xsl:variable name="altova:DesignAfterStep1">
		<altova:main-document url="{if ($SV_BaseOutputFileName) then concat($SV_BaseOutputFileName,'.html') else ''}">
			<html>
				<head>
					<title/>
					<meta name="generator" content="Altova StyleVision Enterprise Edition 2015 (http://www.altova.com)"/>
					<meta http-equiv="X-UA-Compatible" content="IE=9"/>
					<style type="text/css">
						<xsl:comment>.xbrl-table { border-collapse:collapse;
border-color:#AAAAAA;
border-spacing:0px;
border-style:solid;
border-width:1px;
color:#666666;
font-family:Arial;
font-size:11px;
 }
 .xbrl-cell { border-color:#CCCCCC;
border-style:solid;
border-width:1px;
padding:2px;
 }
 .xbrl-cell-table-title { background-color:#EEEEEE;
font-size:14px;
font-weight:bolder;
text-align:left;
vertical-align:top;
 }
 .xbrl-cell-col-title { background-color:#EEEEEE;
padding-left:10px;
vertical-align:top;
 }
 .xbrl-cell-row-title { font-weight:normal;
padding:2px;
text-align:left;
 }
 .xbrl-cell-row-breakdown-title { padding:2px;
text-align:left;
 }
 .xbrl-cell-data { padding-left:10px;
text-align:right;
 }
 .xbrl-footnote { color:#666666;
font-family:Arial;
font-size:11px;
 }
 .xbrl-cell-row-title-level-1 { padding-left:0.25cm;
 }
 .xbrl-cell-row-title-level-2 { padding-left:.5cm;
 }
 .xbrl-cell-row-title-level-3 { padding-left:0.75cm;
 }
 .xbrl-cell-row-title-level-4 { padding-left:1.0cm;
 }
 .xbrl-cell-row-title-level-5 { padding-left:1.25cm;
 }
 .xbrl-cell-row-title-level-6 { padding-left:1.5cm;
 }
 .xbrl-cell-row-title-level-7 { padding-left:1.75cm;
 }
 .xbrl-cell-row-title-level-8 { padding-left:2.0cm;
 }
 .xbrl-cell-row-title-level-9 { padding-left:2.25cm;
 }
 .xbrl-cell-row-title-level-10 { padding-left:2.5cm;
 }</xsl:comment>
					</style>
					<xsl:comment>[if IE]&gt;&lt;STYLE type=&quot;text/css&quot;&gt;.altova-rotate-left-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3)} .altova-rotate-right-textbox{filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1)} &lt;/STYLE&gt;&lt;![endif]</xsl:comment>
					<xsl:comment>[if !IE]&gt;&lt;!</xsl:comment>
					<style type="text/css">.altova-rotate-left-textbox{-webkit-transform: rotate(-90deg) translate(-100%, 0%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(-90deg) translate(-100%, 0%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(-90deg) translate(-100%, 0%); -ms-transform-origin: 0% 0%;}.altova-rotate-right-textbox{-webkit-transform: rotate(90deg) translate(0%, -100%); -webkit-transform-origin: 0% 0%;-moz-transform: rotate(90deg) translate(0%, -100%); -moz-transform-origin: 0% 0%;-ms-transform: rotate(90deg) translate(0%, -100%); -ms-transform-origin: 0% 0%;}</style>
					<xsl:comment>&lt;![endif]</xsl:comment>
					<style type="text/css">@page { margin-left:0.6in; margin-right:0.6in; margin-top:0.79in; margin-bottom:0.79in } @media print { br.altova-page-break { page-break-before: always; } }</style>
				</head>
				<body>
					<xsl:if test="false()">
						<br/>
						<br/>
						<span style="color:gray; font-family:Courier; font-size:larger; ">
							<xsl:text>All charts in this design have been configured using the built-in XBRL Chart Wizard. The list of XBRL concepts available in the XBRL taxonomy is shown in the Schema Tree window under the nodes labeled &apos;Concepts&apos; (below the node labeled &apos;XBRL Taxonomy&apos;). To create a new XBRL chart in the design follow these steps:</xsl:text>
						</span>
						<br/>
						<ol>
							<li>
								<span style="color:gray; font-family:Courier; font-size:larger; ">
									<xsl:text>In the Schema Tree window choose an XBRL concept (for example, &apos;Assets&apos; from &lt;all&gt;)</xsl:text>
								</span>
							</li>
							<li>
								<span style="color:gray; font-family:Courier; font-size:larger; ">
									<xsl:text>Drag and drop the XBRL concept from the Schema Tree window into the Design window</xsl:text>
								</span>
							</li>
							<li>
								<span style="color:gray; font-family:Courier; font-size:larger; ">
									<xsl:text>In the popup menu choose &apos;Create XBRL Chart...&apos;</xsl:text>
								</span>
							</li>
							<li>
								<span style="color:gray; font-family:Courier; font-size:larger; ">
									<xsl:text>In the XBRL Chart Wizard dialog press OK</xsl:text>
								</span>
							</li>
						</ol>
					</xsl:if>
					<div style="background-color:#e9ffff; border-bottom:3px solid #009DC3; border-top:3px solid #009DC3; ">
						<h2 align="center">
							<img>
								<xsl:attribute name="src">
									<xsl:if test="substring(string(&apos;nanonull.gif&apos;), 2, 1) = ':'">
										<xsl:text>file:///</xsl:text>
									</xsl:if>
									<xsl:value-of select="translate(string(&apos;nanonull.gif&apos;), '&#x5c;', '/')"/>
								</xsl:attribute>
								<xsl:attribute name="alt"/>
							</img>
							<span>
								<xsl:text>&#160;</xsl:text>
							</span>
						</h2>
						<h2 align="center">
							<span>
								<xsl:text>Nanonull Financial Statement 2008</xsl:text>
							</span>
						</h2>
					</div>
					<altova:toc altova:name="toc"/>
					<br class="altova-page-break" clear="all"/>
					<h1 style="border-bottom:3px solid #009DC3; ">
						<altova:marker altova:name="toc">
							<span>
								<xsl:text>Statement of Financial Position</xsl:text>
							</span>
						</altova:marker>
					</h1>
					<h2>
						<span>
							<xsl:text>Total Assets</xsl:text>
						</span>
					</h2>
					<img style="height:3.47in; width:6.31in; " title="Total Assets">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:instant ) ][ year-from-date(xbrli:instant) ge 2007 ] )">
									<xsl:sort select="xbrli:instant" data-type="text" order="ascending"/>
									<xsl:variable name="altova:xbrl-contexts-0" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos altova:sLabel="{if (xbrli:instant) then xbrli:instant else if (xbrli:startDate) then concat(xbrli:startDate, ' - ', xbrli:endDate) else if (xbrli:forever) then 'forever' else '?'}">
										<xsl:for-each select="$altova:xbrl-contexts-0">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<altova:Pos>
									<xsl:variable name="altova:xbrl-contexts-1" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:Assets[ some $altova:context in $altova:xbrl-contexts-1 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" ChartKind="LineChart" Title="Total Assets"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>Demonstrates use of a line graph. The periods are of type &apos;instant&apos;, and their default labeling reflects this.</xsl:text>
					</span>
					<br/>
					<br class="altova-page-break" clear="all"/>
					<h1 style="border-bottom:3px solid #009DC3; ">
						<altova:marker altova:name="toc">
							<span>
								<xsl:text>Statement of Income</xsl:text>
							</span>
						</altova:marker>
					</h1>
					<h2>
						<span>
							<xsl:text>Total Revenues and Net Income</xsl:text>
						</span>
					</h2>
					<img style="height:3.47in; width:6.31in; " title="Revenues and Net Income">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:startDate ) ] )">
									<xsl:sort select="xbrli:endDate" data-type="text" order="ascending"/>
									<xsl:variable name="altova:xbrl-contexts-1" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos altova:sLabel="{if (xbrli:instant) then xbrli:instant else if (xbrli:startDate) then concat(xbrli:startDate, ' - ', xbrli:endDate) else if (xbrli:forever) then 'forever' else '?'}">
										<xsl:for-each select="$altova:xbrl-contexts-1">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<altova:Pos altova:sLabel="Net income">
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:NetIncomeLoss[ some $altova:context in $altova:xbrl-contexts-2 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
								<altova:Pos altova:sLabel="Revenues">
									<xsl:variable name="altova:xbrl-contexts-1" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:SalesRevenueServicesGross[ some $altova:context in $altova:xbrl-contexts-1 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" Title="Revenues and Net Income"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>Demonstrates use of a bar graph with two series. This is achieved by selecting both Revenues and Net Income in the Chart Wizard. The periods are of type &apos;duration&apos;, and their default labeling reflects this.</xsl:text>
					</span>
					<br/>
					<br/>
					<img style="height:3.47in; width:6.31in; " title="Revenues and Net Income">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<altova:Pos altova:sLabel="Net income">
									<xsl:variable name="altova:xbrl-contexts-0" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:NetIncomeLoss[ some $altova:context in $altova:xbrl-contexts-0 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
								<altova:Pos altova:sLabel="Revenues">
									<xsl:variable name="altova:xbrl-contexts-3" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:SalesRevenueServicesGross[ some $altova:context in $altova:xbrl-contexts-3 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:startDate ) ] )">
									<xsl:sort select="xbrli:endDate" data-type="text" order="ascending"/>
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos altova:sLabel="{if (xbrli:instant) then xbrli:instant else if (xbrli:startDate) then concat(xbrli:startDate, ' - ', xbrli:endDate) else if (xbrli:forever) then 'forever' else '?'}">
										<xsl:for-each select="$altova:xbrl-contexts-2">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" Title="Revenues and Net Income"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="true()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>The same data as above, but visualized differently. This is achieved by placing the Concepts item in the Categories area instead of the Series area in the XBRL Chart Wizard.</xsl:text>
					</span>
					<br/>
					<br class="altova-page-break" clear="all"/>
					<h2>
						<span>
							<xsl:text>Dividends Declared per Share</xsl:text>
						</span>
					</h2>
					<img style="height:3.47in; width:6.31in; " title="Dividends Declared per Share">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:startDate ) ] )">
									<xsl:sort select="xbrli:endDate" data-type="text" order="ascending"/>
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos altova:sLabel="{concat(round(days-from-duration(xs:date(xbrli:endDate) - xs:date(xbrli:startDate)) div 30), ' months ended ', xbrli:endDate)}">
										<xsl:for-each select="$altova:xbrl-contexts-2">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<altova:Pos>
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:CommonStockDividendsPerShareDeclared[ some $altova:context in $altova:xbrl-contexts-2 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" Title="Dividends Declared per Share"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>Demonstrates use of a bar graph with a single series. The periods use a custom labeling, defined in the Chart Wizard.</xsl:text>
					</span>
					<br/>
					<br/>
					<img style="height:3.47in; width:6.31in; " title="Dividends Declared per Share">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each-group select="$altova:XBRL-xbrl-contexts" group-by="year-from-date(xbrli:period/xbrli:startDate)">
									<xsl:sort select="current-grouping-key()" data-type="number" order="ascending"/>
									<xsl:variable name="altova:xbrl-contexts-4" select="current-group()"/>
									<xsl:for-each select="current-grouping-key()">
										<altova:Pos altova:sLabel="{.}">
											<xsl:for-each select="$altova:xbrl-contexts-4">
												<altova:Context altova:ContextId="{@id}"/>
											</xsl:for-each>
											<xsl:for-each-group select="$altova:xbrl-contexts-4" group-by="(month-from-date(xbrli:period/xbrli:startDate) + 2) idiv 3">
												<xsl:sort select="current-grouping-key()" data-type="number" order="ascending"/>
												<xsl:variable name="altova:xbrl-contexts-2" select="current-group()"/>
												<xsl:for-each select="current-grouping-key()">
													<altova:Pos altova:sLabel="{concat('Q', .)}">
														<xsl:for-each select="$altova:xbrl-contexts-2">
															<altova:Context altova:ContextId="{@id}"/>
														</xsl:for-each>
													</altova:Pos>
												</xsl:for-each>
											</xsl:for-each-group>
										</altova:Pos>
									</xsl:for-each>
								</xsl:for-each-group>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<altova:Pos>
									<xsl:variable name="altova:xbrl-contexts-0" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:CommonStockDividendsPerShareDeclared[ some $altova:context in $altova:xbrl-contexts-0 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" Title="Dividends Declared per Share"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>An alternative approach employing User-Defined Grouping, which allows arbitrary grouping of XBRL facts.</xsl:text>
					</span>
					<br/>
					<br class="altova-page-break" clear="all"/>
					<h1 style="border-bottom:3px solid #009DC3; ">
						<altova:marker altova:name="toc">
							<span>
								<xsl:text>Statement of Cash Flows</xsl:text>
							</span>
						</altova:marker>
					</h1>
					<h2>
						<span>
							<xsl:text>Dividends Paid</xsl:text>
						</span>
					</h2>
					<img style="height:3.47in; width:6.31in; " title="Dividends Paid">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:startDate ) ][ days-from-duration(xs:date(xbrli:endDate) - xs:date(xbrli:startDate)) ge 270 ] )">
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos altova:sLabel="{concat(round(days-from-duration(xs:date(xbrli:endDate) - xs:date(xbrli:startDate)) div 30), ' months ended ', xbrli:endDate)}">
										<xsl:for-each select="$altova:xbrl-contexts-2">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<altova:Pos>
									<xsl:variable name="altova:xbrl-contexts-4" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and fn:count( xbrli:entity/xbrli:segment/xbrldi:explicitMember) + fn:count( xbrli:scenario/xbrldi:explicitMember) = 0]"/>
									<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:PaymentsOfDividends[ some $altova:context in $altova:xbrl-contexts-4 satisfies @contextRef = $altova:context/@id ]">
										<xsl:variable name="altova:current-xbrl-item" select="."/>
										<xsl:variable name="altova:current-xbrl-concept" select="."/>
										<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
									</xsl:for-each>
								</altova:Pos>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" ChartKind="BarChart3d" Title="Dividends Paid"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>Demonstrates use of a 3D bar graph. The periods are filtered so only nine-month periods are displayed.</xsl:text>
					</span>
					<br/>
					<br class="altova-page-break" clear="all"/>
					<h1 style="border-bottom:3px solid #009DC3; ">
						<altova:marker altova:name="toc">
							<span>
								<xsl:text>Disclosure - Segment Revenue and Operating Income</xsl:text>
							</span>
						</altova:marker>
					</h1>
					<h2>
						<span>
							<xsl:text>Revenue by Region (9 months ended 2010-08-31)</xsl:text>
						</span>
					</h2>
					<img style="height:3.47in; width:6.31in; " title="Revenue per Region">
						<xsl:variable name="altova:nChartWidthPx" as="xs:integer" select="606"/>
						<xsl:variable name="altova:nChartHeightPx" as="xs:integer" select="333"/>
						<xsl:variable name="altova:nodeXAxisCategories">
							<xsl:for-each select="$XBRL">
								<xsl:for-each select="altova:distinct-nodes( $altova:XBRL-xbrl-contexts/xbrli:period[ exists( xbrli:startDate ) ][ xbrli:startDate/text() eq &apos;2009-12-01&apos; and xbrli:endDate/text() eq &apos;2010-08-31&apos; ] )">
									<xsl:variable name="altova:xbrl-contexts-2" select="$altova:XBRL-xbrl-contexts[ fn:deep-equal( xbrli:period, current() ) ]"/>
									<altova:Pos>
										<xsl:for-each select="$altova:xbrl-contexts-2">
											<altova:Context altova:ContextId="{@id}"/>
										</xsl:for-each>
										<xsl:if test="true()">
											<xsl:variable name="altova:xbrl-contexts-5" select="$altova:xbrl-contexts-2[ some $altova:explicitMember in xbrli:entity/xbrli:segment/xbrldi:explicitMember satisfies ( fn:resolve-QName( xs:string($altova:explicitMember/@dimension), $altova:explicitMember ) eq fn:QName( &apos;http://fasb.org/us-gaap/2013-01-31&apos;, &apos;StatementOperatingActivitiesSegmentAxis&apos; ) and fn:resolve-QName( $altova:explicitMember/text(), $altova:explicitMember ) eq fn:QName( &apos;http://www.altova.com/nanonull&apos;, &apos;USA&apos; ) ) ]"/>
											<xsl:if test="exists( $altova:xbrl-contexts-5 )">
												<altova:Pos altova:sLabel="USA">
													<xsl:for-each select="$altova:xbrl-contexts-5">
														<altova:Context altova:ContextId="{@id}"/>
													</xsl:for-each>
												</altova:Pos>
											</xsl:if>
											<xsl:variable name="altova:xbrl-contexts-6" select="$altova:xbrl-contexts-2[ some $altova:explicitMember in xbrli:entity/xbrli:segment/xbrldi:explicitMember satisfies ( fn:resolve-QName( xs:string($altova:explicitMember/@dimension), $altova:explicitMember ) eq fn:QName( &apos;http://fasb.org/us-gaap/2013-01-31&apos;, &apos;StatementOperatingActivitiesSegmentAxis&apos; ) and fn:resolve-QName( $altova:explicitMember/text(), $altova:explicitMember ) eq fn:QName( &apos;http://www.altova.com/nanonull&apos;, &apos;Europe&apos; ) ) ]"/>
											<xsl:if test="exists( $altova:xbrl-contexts-6 )">
												<altova:Pos altova:sLabel="Europe">
													<xsl:for-each select="$altova:xbrl-contexts-6">
														<altova:Context altova:ContextId="{@id}"/>
													</xsl:for-each>
												</altova:Pos>
											</xsl:if>
											<xsl:variable name="altova:xbrl-contexts-7" select="$altova:xbrl-contexts-2[ some $altova:explicitMember in xbrli:entity/xbrli:segment/xbrldi:explicitMember satisfies ( fn:resolve-QName( xs:string($altova:explicitMember/@dimension), $altova:explicitMember ) eq fn:QName( &apos;http://fasb.org/us-gaap/2013-01-31&apos;, &apos;StatementOperatingActivitiesSegmentAxis&apos; ) and fn:resolve-QName( $altova:explicitMember/text(), $altova:explicitMember ) eq fn:QName( &apos;http://www.altova.com/nanonull&apos;, &apos;Asia&apos; ) ) ]"/>
											<xsl:if test="exists( $altova:xbrl-contexts-7 )">
												<altova:Pos altova:sLabel="Asia">
													<xsl:for-each select="$altova:xbrl-contexts-7">
														<altova:Context altova:ContextId="{@id}"/>
													</xsl:for-each>
												</altova:Pos>
											</xsl:if>
										</xsl:if>
									</altova:Pos>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeXAxisSeries">
							<xsl:for-each select="$XBRL">
								<xsl:if test="true()">
									<altova:Pos>
										<xsl:variable name="altova:xbrl-contexts-1" select="$altova:XBRL-xbrl-contexts[ fn:count( xbrli:entity/xbrli:segment/xbrldi:typedMember) + fn:count( xbrli:scenario/xbrldi:typedMember) = 0 and not( some $altova:explicitMember in xbrli:entity/xbrli:segment/xbrldi:explicitMember satisfies ( fn:resolve-QName( xs:string($altova:explicitMember/@dimension), $altova:explicitMember ) ne fn:QName( &apos;http://fasb.org/us-gaap/2013-01-31&apos;, &apos;StatementOperatingActivitiesSegmentAxis&apos; )) )]"/>
										<xsl:for-each select="$XBRL/xbrli:xbrl/us-gaap:SegmentReportingInformationRevenue[ some $altova:context in $altova:xbrl-contexts-1 satisfies @contextRef = $altova:context/@id ]">
											<xsl:variable name="altova:current-xbrl-item" select="."/>
											<xsl:variable name="altova:current-xbrl-concept" select="."/>
											<altova:Context altova:ContextId="{@contextRef}" altova:Value="{.}"/>
										</xsl:for-each>
									</altova:Pos>
								</xsl:if>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:extChartConfig" as="item()*">
							<xsl:variable name="altova:ext-chart-settings" as="item()*">
								<chart-config>
									<General SettingsVersion="2" ChartKind="Pie" Title="Revenue per Region"/>
								</chart-config>
							</xsl:variable>
							<xsl:sequence select="altovaext:create-chart-config-from-xml( $altova:ext-chart-settings )"/>
						</xsl:variable>
						<xsl:variable name="altova:bValuesInCategory" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:seqCategoryLeafPos" select="$altova:nodeXAxisCategories//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqSeriesLeafPos" select="$altova:nodeXAxisSeries//altova:Pos[empty(descendant::altova:Pos)]"/>
						<xsl:variable name="altova:seqCategoryLabels" select="for $nodeCategoryLeafPos in $altova:seqCategoryLeafPos return altova:GetChartLabelForPos($nodeCategoryLeafPos)" as="xs:string*"/>
						<xsl:variable name="altova:bRemoveEmptyCategories" as="xs:boolean" select="false()"/>
						<xsl:variable name="altova:bRemoveEmptySeries" as="xs:boolean" select="false()"/>
						<!-- Contains empty categories and series, if present -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeriesLeafPos">
								<xsl:element name="altova:nodeSeries">
									<xsl:element name="altova:sSeriesLabel">
										<xsl:value-of select="altova:GetChartLabelForPos(.)"/>
									</xsl:element>
									<xsl:copy-of select="altova:GetChartYValuesForSingleSeries($altova:seqCategoryLeafPos, ., $altova:bValuesInCategory)"/>
								</xsl:element>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:seqColumnHasContent" as="xs:boolean*" select="for $i in 1 to count($altova:seqSeries[1]/altova:Value) return some $j in $altova:seqSeries satisfies $j/altova:Value[$i] ne 'altova:no-value'"/>
						<!-- Category labels: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqCategoryLabels" as="xs:string*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return $altova:seqCategoryLabels[$i][$altova:seqColumnHasContent[$i]]"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqCategoryLabels"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty series if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptySeries">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:if test="some $Value in altova:Value satisfies $Value ne 'altova:no-value'">
											<xsl:copy-of select="."/>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<!-- Values: Remove empty categories if necessary -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:choose>
								<xsl:when test="$altova:bRemoveEmptyCategories">
									<xsl:for-each select="$altova:seqSeries">
										<xsl:copy>
											<xsl:copy-of select="altova:sSeriesLabel"/>
											<xsl:copy-of select="for $i in 1 to count($altova:seqColumnHasContent) return altova:Value[$i][$altova:seqColumnHasContent[$i]]"/>
										</xsl:copy>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:copy-of select="$altova:seqSeries"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="altova:nodeDataSet" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:sequence select="altovaext:create-chart-data-series(altova:sSeriesLabel, $altova:seqCategoryLabels, altova:Value)"/>
							</xsl:for-each>
						</xsl:variable>
						<!-- Values: Remove any remaining 'no-value' markers -->
						<xsl:variable name="altova:seqSeries" as="item()*">
							<xsl:for-each select="$altova:seqSeries">
								<xsl:copy>
									<xsl:copy-of select="altova:sSeriesLabel"/>
									<xsl:for-each select="altova:Value">
										<xsl:choose>
											<xsl:when test=". eq 'altova:no-value'">
												<xsl:element name="altova:Value">
													<xsl:text>0</xsl:text>
												</xsl:element>/></xsl:when>
											<xsl:otherwise>
												<xsl:copy-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</xsl:copy>
							</xsl:for-each>
						</xsl:variable>
						<xsl:variable name="altova:nodeChart" select="altovaext:create-chart($altova:extChartConfig, $altova:nodeDataSet)"/>
						<xsl:variable name="altova:sChartFileName">
							<xsl:variable name="tempValue" as="xs:string" select="altova:map-preview-filepath( concat( $SV_GeneratedFileNamePrefix, &apos;_SVGeneratedChart&apos;, &apos;_&apos;, altovaext:generate-auto-number( &apos;sv_chart&apos;, 1, 1, &apos;&apos; ), &apos;.png&apos; ) )"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:variable name="altova:sChartFileNameNoPath">
							<xsl:variable name="tempValue" as="xs:string" select="for $matchexpr in &apos;.*(\\|/)([^/\\]+)$&apos; return if ( matches( $altova:sChartFileName, $matchexpr ) ) then replace( $altova:sChartFileName, $matchexpr, &apos;$2&apos; ) else $altova:sChartFileName"/>
							<xsl:sequence select="$tempValue"/>
							<xsl:if test="not( string( $tempValue ) )">
								<xsl:message select="'Error: generated file name is empty.'" terminate="yes"/>
							</xsl:if>
						</xsl:variable>
						<xsl:attribute name="alt" select="'Altova StyleVision Chart'"/>
						<xsl:attribute name="altova:ImageDataBase64" select="altovaext:generate-chart-image( $altova:nodeChart, xs:integer($altova:nChartWidthPx), xs:integer($altova:nChartHeightPx), &apos;x-binarytobase64&apos;, tokenize($altova:sChartFileName, &apos;\.&apos;)[last()]  )"/>
						<xsl:attribute name="src" select="$altova:sChartFileName"/>
					</img>
					<br/>
					<span style="font-style:italic; ">
						<xsl:text>Demonstrates use of a pie chart. The breakdown by region is performed according to the &apos;Operating Activities&apos; dimension defined in the XBRL taxonomy.</xsl:text>
					</span>
				</body>
			</html>
		</altova:main-document>
	</xsl:variable>
	<xsl:template match="altova:toc[ @altova:name = 'toc' ]" mode="altova:generate-toc-xslt-tree">
		<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
		<altova:toc altova:design-id="{generate-id()}">
			<xsl:variable name="altova:current-level-id" select="generate-id( ancestor::altova:level[1] )"/>
			<h1>
				<span>
					<xsl:text>Table of Contents</xsl:text>
				</span>
			</h1>
			<xsl:for-each select="ancestor::altova:main-document">
				<xsl:variable name="altova:current-level-id" select="generate-id( ancestor::altova:level[1] )"/>
				<xsl:for-each select="descendant::altova:marker[ @altova:name = 'toc' ]">
					<xsl:variable name="altova:current-marker-id" select="generate-id()"/>
					<a href="{concat(altova:calc-relative-path($altova:source-document/@url,ancestor::*[self::altova:result-document | self::altova:main-document][1]/@url),'#',generate-id())}">
						<h3>
							<span>
								<xsl:choose>
									<xsl:when test="@altova:entrytext">
										<xsl:value-of select="@altova:entrytext"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:apply-templates mode="altova:extract-text-from-marker">
											<xsl:with-param name="altova:level-design-id" select="$altova:current-level-id"/>
											<xsl:with-param name="altova:marker-design-id" select="$altova:current-marker-id"/>
										</xsl:apply-templates>
									</xsl:otherwise>
								</xsl:choose>
							</span>
						</h3>
					</a>
				</xsl:for-each>
			</xsl:for-each>
		</altova:toc>
	</xsl:template>
	<xsl:template match="xbrli:measure">
		<xsl:choose>
			<xsl:when test="fn:resolve-QName( text(), . ) eq fn:QName( &apos;http://www.xbrl.org/2003/iso4217&apos;, &apos;USD&apos; )">
				<span>
					<xsl:text>$</xsl:text>
				</span>
			</xsl:when>
			<xsl:when test="fn:resolve-QName( text(), . ) eq fn:QName( &apos;http://www.xbrl.org/2003/iso4217&apos;, &apos;EUR&apos; )">
				<span>
					<xsl:text>â¬</xsl:text>
				</span>
			</xsl:when>
			<xsl:when test="fn:resolve-QName( text(), . ) eq fn:QName( &apos;http://www.xbrl.org/2003/iso4217&apos;, &apos;GBP&apos; )">
				<span>
					<xsl:text>Â£</xsl:text>
				</span>
			</xsl:when>
			<xsl:when test="fn:resolve-QName( text(), . ) eq fn:QName( &apos;http://www.xbrl.org/2003/iso4217&apos;, &apos;JPY&apos; )">
				<span>
					<xsl:text>Â¥</xsl:text>
				</span>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="monetaryItemType">
		<xsl:choose>
			<xsl:when test="number( . ) &gt;= 0">
				<span>
					<xsl:variable name="altova:seqContentStrings_8">
						<xsl:value-of select="format-number(number(number( . ) div 1000000), '###Â ##0,##', 'format1')"/>
					</xsl:variable>
					<xsl:variable name="altova:sContent_8" select="string($altova:seqContentStrings_8)"/>
					<xsl:value-of select="$altova:sContent_8"/>
				</span>
			</xsl:when>
			<xsl:otherwise>
				<span>
					<xsl:text>(</xsl:text>
				</span>
				<span>
					<xsl:variable name="altova:seqContentStrings_9">
						<xsl:value-of select="format-number(number(number( . ) * -1 div 1000000), '###Â ##0,##', 'format1')"/>
					</xsl:variable>
					<xsl:variable name="altova:sContent_9" select="string($altova:seqContentStrings_9)"/>
					<xsl:value-of select="$altova:sContent_9"/>
				</span>
				<span>
					<xsl:text>)</xsl:text>
				</span>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="monetaryItemTypeNegative">
		<xsl:choose>
			<xsl:when test="number( . ) &gt;= 0">
				<span>
					<xsl:text>(</xsl:text>
				</span>
				<span>
					<xsl:variable name="altova:seqContentStrings_10">
						<xsl:value-of select="format-number(number(number( . ) div 1000000), '###Â ##0,##', 'format1')"/>
					</xsl:variable>
					<xsl:variable name="altova:sContent_10" select="string($altova:seqContentStrings_10)"/>
					<xsl:value-of select="$altova:sContent_10"/>
				</span>
				<span>
					<xsl:text>)</xsl:text>
				</span>
			</xsl:when>
			<xsl:otherwise>
				<span>
					<xsl:variable name="altova:seqContentStrings_11">
						<xsl:value-of select="format-number(number(number( . ) * -1 div 1000000), '###Â ##0,##', 'format1')"/>
					</xsl:variable>
					<xsl:variable name="altova:sContent_11" select="string($altova:seqContentStrings_11)"/>
					<xsl:value-of select="$altova:sContent_11"/>
				</span>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="perShareItemType">
		<xsl:choose>
			<xsl:when test=". instance of element()">
				<xsl:apply-templates/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="."/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="stringItemType">
		<xsl:choose>
			<xsl:when test=". instance of element()">
				<xsl:apply-templates/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="."/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="textBlockItemType">
		<xsl:choose>
			<xsl:when test=". instance of element()">
				<xsl:apply-templates/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="."/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="/">
		<xsl:for-each select="$altova:DesignAfterStep1">
			<xsl:apply-templates mode="altova:step2"/>
		</xsl:for-each>
		<xsl:for-each select="$altova:DesignAfterStep1//img[@altova:ImageDataBase64]">
			<xsl:result-document href="{@src}" method="text" encoding="x-base64tobinary">
				<xsl:value-of select="@altova:ImageDataBase64"/>
			</xsl:result-document>
		</xsl:for-each>
		<xsl:for-each select="$altova:toc-xslt-tree//img[@altova:ImageDataBase64]">
			<xsl:result-document href="{@src}" method="text" encoding="x-base64tobinary">
				<xsl:value-of select="@altova:ImageDataBase64"/>
			</xsl:result-document>
		</xsl:for-each>
		<xsl:if test="$altova:bGeneratingFromPxf">
			<xsl:for-each select="distinct-values(for $i in $altova:DesignAfterStep1//img[not(@altova:ImageDataBase64)]/@src return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://') or starts-with(., 'file:///') or substring(., 2, 2) = ':\' or substring(., 2, 2) = ':/')">
					<xsl:if test="unparsed-text-available(., 'x-binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="x-base64tobinary">
							<xsl:value-of select="unparsed-text(., 'x-binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="distinct-values(for $i in $altova:toc-xslt-tree//img[not(@altova:ImageDataBase64)]/@src return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://') or starts-with(., 'file:///') or substring(., 2, 2) = ':\' or substring(., 2, 2) = ':/')">
					<xsl:if test="unparsed-text-available(., 'x-binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="x-base64tobinary">
							<xsl:value-of select="unparsed-text(., 'x-binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
			<xsl:for-each select="distinct-values(for $i in $altova:CssImages/altova:CssImage/@altova:sUrl return lower-case($i))">
				<xsl:if test="not(starts-with(., 'http://') or starts-with(., 'ftp://') or starts-with(., 'file:///') or substring(., 2, 2) = ':\' or substring(., 2, 2) = ':/')">
					<xsl:if test="unparsed-text-available(., 'x-binarytobase64')">
						<xsl:result-document href="{.}" method="text" encoding="x-base64tobinary">
							<xsl:value-of select="unparsed-text(., 'x-binarytobase64')"/>
						</xsl:result-document>
					</xsl:if>
				</xsl:if>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:step2">
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="img" mode="altova:step2">
		<img>
			<xsl:copy-of select="@* except @altova:*"/>
		</img>
	</xsl:template>
	<xsl:template match="table" mode="altova:step2">
		<xsl:variable name="altova:table">
			<xsl:copy copy-namespaces="no">
				<xsl:apply-templates select="@* | node()" mode="#current"/>
			</xsl:copy>
		</xsl:variable>
		<xsl:apply-templates select="$altova:table" mode="altova:generate-table"/>
	</xsl:template>
	<xsl:variable name="altova:toc-xslt-tree1">
		<xsl:for-each select="$altova:DesignAfterStep1">
			<xsl:apply-templates mode="altova:generate-toc-xslt-tree"/>
		</xsl:for-each>
	</xsl:variable>
	<xsl:template match="altova:level" mode="altova:generate-toc-xslt-tree">
		<altova:level altova:design-id="{generate-id()}">
			<xsl:apply-templates mode="#current"/>
		</altova:level>
	</xsl:template>
	<xsl:template match="altova:marker" mode="altova:generate-toc-xslt-tree">
		<altova:marker altova:design-id="{generate-id()}" altova:name="{@altova:name}">
			<xsl:apply-templates mode="#current"/>
		</altova:marker>
	</xsl:template>
	<xsl:template match="@* | text()" mode="altova:generate-toc-xslt-tree"/>
	<xsl:template match="altova:UnescapedText" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy copy-namespaces="no">
			<xsl:apply-templates mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="text()" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="altova:num-lvl" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy>
			<xsl:copy-of select="@*"/>
			<xsl:attribute name="altova:level-design-id" select="$altova:level-design-id"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:num-seq" mode="altova:extract-text-from-marker">
		<xsl:param name="altova:level-design-id"/>
		<xsl:param name="altova:marker-design-id"/>
		<xsl:copy>
			<xsl:copy-of select="@*"/>
			<xsl:attribute name="altova:marker-design-id" select="generate-id( ancestor::altova:marker[1] )"/>
		</xsl:copy>
	</xsl:template>
	<xsl:variable name="altova:toc-xslt-tree" select="$altova:toc-xslt-tree1"/>
	<xsl:key name="altova:bookmark-key" match="altova:bookmark" use="@name"/>
	<xsl:key name="altova:toc-xslt-tree-key" match="altova:level | altova:toc | altova:ref | altova:marker" use="@altova:design-id"/>
	<xsl:template match="altova:main-document" mode="altova:step2">
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:level" mode="altova:step2">
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:bookmark | altova:hyperlink" mode="altova:step2">
		<a>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</a>
	</xsl:template>
	<xsl:template match="altova:hyperlink/@href[starts-with(.,'#')]" mode="altova:step2">
		<xsl:variable name="altova:bookmark-name" select="substring(.,2)"/>
		<xsl:attribute name="href">
			<xsl:variable name="altova:source-document" select="ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
			<xsl:variable name="altova:target-document" select="key('altova:bookmark-key',$altova:bookmark-name,$altova:DesignAfterStep1)[1]/ancestor::*[self::altova:result-document | self::altova:main-document][1]"/>
			<xsl:value-of select="concat(altova:calc-relative-path($altova:source-document/@url,$altova:target-document/@url),.)"/>
		</xsl:attribute>
	</xsl:template>
	<xsl:template match="altova:toc | altova:ref" mode="altova:step2">
		<xsl:apply-templates select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', generate-id( current() ) )/node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:marker" mode="altova:step2">
		<a name="{generate-id()}"/>
		<xsl:apply-templates select="node()" mode="#current"/>
	</xsl:template>
	<xsl:template match="altova:num-lvl" mode="altova:step2">
		<xsl:variable name="altova:format" select="@altova:format"/>
		<xsl:variable name="altova:omit-levels" select="@altova:omit-levels"/>
		<xsl:variable name="altova:level-design-id">
			<xsl:choose>
				<xsl:when test="@altova:level-design-id">
					<xsl:value-of select="@altova:level-design-id"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="generate-id( ancestor::altova:level[1] )"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:for-each select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', $altova:level-design-id )">
			<xsl:choose>
				<xsl:when test="$altova:omit-levels">
					<xsl:number level="multiple" count="altova:level[ count( ancestor::altova:level ) >= $altova:omit-levels ]" format="{$altova:format}"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:number level="multiple" count="altova:level" format="{$altova:format}"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="altova:num-seq" mode="altova:step2">
		<xsl:variable name="altova:format" select="@altova:format"/>
		<xsl:variable name="altova:marker-design-id">
			<xsl:choose>
				<xsl:when test="@altova:marker-design-id">
					<xsl:value-of select="@altova:marker-design-id"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="generate-id( ancestor::altova:marker[1] )"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:for-each select="$altova:toc-xslt-tree/key( 'altova:toc-xslt-tree-key', $altova:marker-design-id )">
			<xsl:variable name="altova:name" select="@altova:name"/>
			<xsl:number level="any" count="altova:marker[ @altova:name = $altova:name ]" format="{$altova:format}"/>
		</xsl:for-each>
	</xsl:template>
	<xsl:function name="altova:calc-relative-path" as="xs:string">
		<xsl:param name="altova:source-path"/>
		<xsl:param name="altova:target-path"/>
		<xsl:choose>
			<xsl:when test="$altova:source-path = $altova:target-path">
				<xsl:sequence select="''"/>
			</xsl:when>
			<xsl:when test="starts-with($altova:target-path,'http:') or starts-with($altova:target-path,'ftp:') or starts-with($altova:target-path,'file:')">
				<xsl:sequence select="$altova:target-path"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:source-parts" select="tokenize($altova:source-path,'[/\\]')"/>
				<xsl:variable name="altova:target-parts" select="tokenize($altova:target-path,'[/\\]')"/>
				<xsl:variable name="altova:common-part-count" select="sum(for $i in (1 to count($altova:source-parts) - 1) return if( subsequence($altova:source-parts,1,$i) = subsequence($altova:target-parts,1,$i) ) then 1 else 0)"/>
				<xsl:sequence select="string-join((for $i in ($altova:common-part-count + 1 to count($altova:source-parts) - 1) return '..',for $i in ($altova:common-part-count + 1 to count($altova:target-parts)) return $altova:target-parts[$i]),'/')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:map-preview-filepath" as="xs:string">
		<xsl:param name="filepath"/>
		<xsl:sequence select="altovaext:create-temp-file-mapping($filepath)" use-when="function-available('altovaext:create-temp-file-mapping',1)"/>
		<xsl:sequence select="$filepath" use-when="not(function-available('altovaext:create-temp-file-mapping',1))"/>
	</xsl:function>
	<xsl:function name="altova:is-cell-empty" as="xs:boolean">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="altova:is-node-empty( $altova:cell )"/>
	</xsl:function>
	<xsl:function name="altova:is-node-empty" as="xs:boolean">
		<xsl:param name="altova:node" as="element()"/>
		<xsl:sequence select="every $altova:child in $altova:node/child::node() satisfies ( ( boolean( $altova:child/self::text() ) and string-length( $altova:child ) = 0 ) or ( ( boolean( $altova:child/self::div ) or boolean( $altova:child/self::span ) or boolean( $altova:child/self::a ) ) and altova:is-node-empty( $altova:child ) ) )"/>
	</xsl:function>
	<xsl:function name="altova:col-span" as="xs:integer">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="if ( exists( $altova:cell/@colspan ) ) then xs:integer( $altova:cell/@colspan ) else 1"/>
	</xsl:function>
	<xsl:template match="@* | node()" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current">
				<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="tbody" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:choose>
			<xsl:when test="empty(tr)">
				<xsl:copy>
					<tr>
						<td/>
					</tr>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current">
						<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
					</xsl:apply-templates>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="th | td" mode="altova:generate-table">
		<xsl:choose>
			<xsl:when test="altova:is-cell-empty( . )">
				<xsl:copy>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:text>&#160;</xsl:text>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="altova:GetChartYValuesForSingleSeries">
		<xsl:param name="seqCategoryLeafPos" as="node()*"/>
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:for-each select="$seqCategoryLeafPos">
			<xsl:element name="altova:Value">
				<xsl:value-of select="altova:GetChartYValueForSingleSeriesPos($nodeSeriesLeafPos, ., $bValuesInCategory)"/>
			</xsl:element>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="altova:GetChartYValueForSingleSeriesPos">
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="nodeCategoryLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:variable name="altova:seqCategoryContextIds" select="$nodeCategoryLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:seqSeriesContextIds" select="$nodeSeriesLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:sCommonContextId" select="for $i in $altova:seqCategoryContextIds return if (some $j in $altova:seqSeriesContextIds satisfies $i eq $j) then $i else ()" as="xs:string*"/>
		<xsl:choose>
			<xsl:when test="count($altova:sCommonContextId) gt 1">
				<xsl:message select="concat('Found several values instead of a single one (contexts: ', string-join($altova:sCommonContextId, ', '), ').')" terminate="yes"/>
			</xsl:when>
			<xsl:when test="count($altova:sCommonContextId) lt 1">
				<xsl:message select="concat('XBRL Chart: Info: No value found for position labeled &quot;', $nodeCategoryLeafPos/@altova:sLabel, '&quot;')" terminate="no"/>
				<xsl:sequence select="'altova:no-value'"/>
			</xsl:when>
			<xsl:when test="$bValuesInCategory">
				<xsl:sequence select="xs:string($nodeCategoryLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="xs:string($nodeSeriesLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartLabelForPos" as="xs:string">
		<xsl:param name="nodeParam" as="node()"/>
		<xsl:value-of select="string-join($nodeParam/ancestor-or-self::altova:Pos/@altova:sLabel, ' ')"/>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-pixel" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="substring-before($normLength, 'px')"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * $altova:nPxPerIn"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * $altova:nPxPerIn div 2.54"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'mm')) * $altova:nPxPerIn div 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * $altova:nPxPerIn div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * $altova:nPxPerIn div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$normLength"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-mm" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'px')) div $altova:nPxPerIn * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * 10"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="substring-before($normLength, 'mm') "/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * 25.4 div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * 25.4 div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($normLength) div $altova:nPxPerIn * 25.4"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
</xsl:stylesheet>
